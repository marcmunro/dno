#! /usr/bin/make -f 
#  dno
# 
#       Self-executing makefile for dno, the Arduino build system
#	Execute "dno help" or "dno info" for more information.
# 
#       Copyright (c) 2024, 2025 Marc Munro
#       Author:  Marc Munro
# 	License: GPL-3.0
#  
#

# TODOs:
# Handle boards.local.txt
# handle filenames with spaces and other stupid characters
# allow boards.local.txt
# test upload for esp32
# docs
# Compare ide build with our build
# Allow for tests to be in different directory from lib
# Add programmers.txt into BOARD_INFO
# deb package build
# dirnames containing spaces
# dirnames containing commas

# Version and configuration stuff
#
DNO_VERSION = @DNO_VERSION@
EXTRA_BOARDS_FILE=@DNO_EXTRA_BOARDS_FILE@

# Do not use make's built-in rules
# (this improves performance and avoids hard-to-debug behaviour).
#
MAKEFLAGS += -r

# We need bash for the pipefail option.
#
SHELL = bash


###########
# Configuration values
# You might want to change these, specify them on the command line or
# in an included makefile.

# Everything will be built in and below the following directory.
#
BUILD_DIR = build


###########
# Feedback controls.
#
# Define VERBOSE on the command line to show the full compilation, etc
# commands, and to show a more full display of object size info.
#
# Define REPORT to cause each target to be reported upon.  This is
# automatically done when VERBOSE is defined.
#
# Define QUIET to prevent the automatic display of object size information.
#
# Define SHOW_RULES to show the generation of automatically created rules.
#
# Define DEBUG to show the calculated values of key variables.  This can be Y,
# Yes, or a regexp to match only the variables we want.
#

# If VERBOSE is defined $(FEEDBACK) will do nothing and $(AT) will have no
# effect, otherwise $(FEEDBACK) will perform an echo and $(AT) will make the
# command that follows it execute quietly.  Setting VERBOSE to N will
# cause it to become undefined.  This allows us to explicitly unset
# VERBOSITY for certain recursive calls.
#

ifdef VERBOSE
    ifeq "$(VERBOSE)" "N"
        override undefine VERBOSE
        override undefine DEBUG
        override undefine REPORT
    endif
endif

ifdef VERBOSE
    FEEDBACK = @true
    FEEDBACK_RAW = true
    QUIET = 
    AT =
    REPORT = true
else
    FEEDBACK = @echo " "
    FEEDBACK_RAW = echo " "
    QUIET = 2>/dev/null
    AT = @
endif

# TARGET echoes the current target when REPORT is defined.  
#
ifdef REPORT
    TARGET = @echo BUILDING TARGET[$(MAKE_RESTARTS)] $@
else
    TARGET = @true
endif

# If SHOW_RULES is defined feedback will be provided from the recursive rule
# building macros.  This is intended for debugging dno.
#
ifdef SHOW_RULES
    feedback = $(info $1)
endif

# If DEBUG is defined, we can show the values of certain defined variables:
# those that are followed by calls to $(call debug) within this file.  DEBUG
# may be given the value Y, yes or all to show all such instrumented variables,
# or may be a (grep) regexp that matches the names of only those variables we 
# are interested in.
#
ifdef DEBUG
  debug = $(if $(shell echo $(DEBUG) | grep -i "^\(y\|yes\|all\)$$"),\
	    $(info DBG: $1 = $($1)),\
	    $(if $(shell echo $1 | grep "$(DEBUG)"), $(info DBG: $1 = $($1))))
   DBG = @echo DBG: 
else
   DBG = @true
endif

# Pass relevant verbosity variables to any recursive make
#
export DEBUG VERBOSE FEEDBACK


###########
# General definitions
#

# Figure out the path to this makefile.
#
MAKEFILEPATH := $(realpath $(call lastword,$(MAKEFILE_LIST)))
THIS_MAKEFILE := $(firstword $(MAKEFILE_LIST))
BINDIR := $(realpath $(dir $(MAKEFILEPATH)))
REAL_MAKE := $(MAKE)
MAKE := $(THIS_MAKEFILE)


###########
# Helper macros and related definitions.
#

# empty definition.  Needed by the succeeding definition for "space".
#
empty :=

# An explicit space definition for use in macros.  Generally, macros eliminate
# leading spaces.  Using this definition prevents that.
#
space := $(empty) $(empty)

##
# is_std_lib:
# $1 is considered a library if it contains a .h file with the same
# stem as the directory name.  Result is $1 if it is a standard lib.
#
is_std_lib = $(and $(wildcard $(1)/$(notdir $(1)).h), $(1))

##
# is_special_lib
# $1 is considered a special lib, if it contains a src dir containing
# a header with the same stem as the directory name.  Result is $1 if
# it is a special lib. 
#
is_special_lib = $(and $(wildcard $(1)/src/$(notdir $(1)).h), $(1)/src)

##
# is_lib
# Check each dir in $1 to see if it is either a std lib or special
# lib.  Result will be each entry from $1 that is either a standard
# or special lib.
#
is_lib = $(foreach lib,$(1), \
	     $(or $(call is_std_lib,$(lib)), \
		  $(call is_special_lib,$(lib))))

##
# deplibs
# $1 - path of library root
# $2 - list of dependency files
# Return libraries referenced in $2 that can be found in the directory $1
#
deplibs = $(sort \
            $(foreach lib, \
	      $(sort \
	        $(strip \
		  $(shell grep -sh "^ *.*$(notdir $(1))/" \
		                   $2 /dev/null))),\
	        $(if $(filter $(realpath $(dir $(lib))), $(realpath $(1))),\
	          $(1))))

##
# unbuilt_deps
#   $1 - list of dependency files.  These may or may not have been
#        already generated.
# Return the list of dependency files (from $1) that do not currently
# exist.
#
unbuilt_deps = $(foreach dep,$1,$(if $(wildcard $(dep)),,$(dep)))

##
# libname
# Return the library name from a directory path that may include a src
# subdir. 
#
libname = $(notdir $(subst /src,,$(patsubst %/,%,$1)))

##
# filepart
# Functionally equivalent to notdir builtin that can be executed using
# $(call...
# This makes it usable as a filter transform function for uniqify.
# $1 - relative or absolute pathname of file.
#
filepart = $(notdir $1)

##
# eq
# Boolean.  Returns value if $1 and $2 are equal
# 
eq = $(and $(findstring $(strip $1),$(strip $2)),\
	   $(findstring $(strip $2),$(strip $1)))

##
# not
# Boolean "not" function.
#
not = $(if $(strip $1),,t)

##
# apply
# Apply a filter transform function to $1
# $1 - value to possibly be operated on
# $2 - the name of a filter transform function (or empty) that will be
#      applied to $1.  If this is empty $1 is returned verbatim.
#
apply = $(if $2,$(call $2,$1),$1)

##
# match
# Boolean.  Returns a value if $3 applied to $2 matches $1.
# $1 - value to be checked against
# $2 - raw value to be transformed before checking against $1
# $3 - filter transform function to be applied to $2 before it is
#      checked for equality with $1
#
match = $(call eq,$1,$(call apply,$2,$3))

##
# rest
# Return all but the first word from $1
#
rest = $(wordlist 2,99999,$1)

##
# remove
# Remove items matching the singular $1 from the list $2
# $1 - match.  Items matching this will be removed from $2
# $2 - wordlist.
# $3 - filter transform function.  Each word in $2 will be transformed
#      using this function before being checked for a match with $1
#
remove = $(strip $(if $(strip $2), \
	             $(if $(strip $(call match,$1,$(firstword $2),$3)),,\
	               $(firstword $2)) \
	             $(call remove,$1,$(call rest,$2),$3)))

##
# minus
#   $1 list of things
#   $2 another list of things
# Result is the set of things in $1 that do not appear in $2.
#
minus = $(if $2,\
	     $(call remove,$(firstword $2),\
		           $(call minus,$1,$(call rest,$2),$3),$3),\
	   $1)

##
# uniqify
# Remove duplicate matches from a list.
#   $1 - list of words
#   $2 - filter transform (match) function
#
# If a list contains something like path1/lib1 path2/lib2 path3/lib1
# and the "filepart" filter tranform function is used, the second lib1
# reference will be removed from the list.
#
uniqify = $(if $(strip $1),\
	      $(firstword $1) \
	      $(call uniqify,\
	             $(call remove,\
		            $(call apply,$(firstword $1),$2),\
		            $(call rest,$1),$2)))
##
# matching_files
#   $1 Set of patterns to match for
#   $2 Set of directories within which matches may be found
# Return a list of files matching a set of patterns ($1) from a set of
# directories ($2). 
#
matching_files = $(foreach pattern, $(1),\
	            $(foreach dir, $(2),\
	               $(wildcard $(dir)/$(pattern))))
##
# to_objects
#   $1 Target directory
#   $2 Set of source file names.
# Translate source file names into object file paths.  The objects
# files will all be placed in the given target directory.
#
to_objects = $(filter-out $(ignore_objects), $(patsubst %.ino, $(1)/%.ino.o,\
		 $(patsubst %.S, $(1)/%.S.o,\
		   $(patsubst %.c, $(1)/%.o,\
                     $(patsubst %.cpp, $(1)/%.o, $(notdir $(2)))))))

##
# RECURSE_FOR_SUBDIRECTORIES
# This macro is to be placed into a recipe to cause dno to run
# recursively in subdirectories.  It is intended for the "clean" and related
# targets.
#
define RECURSE_FOR_SUBDIRS
	find . -mindepth 1 -maxdepth 1 -type d ! -name html | \
	  while read dir; do \
	    if [ "`basename $${dir}`" != ".git" ]; then \
	      ( cd $${dir}; \
	        $(MAKE) --no-print-directory -j1 STARTDIR=$(STARTDIR) $@); \
	    fi; \
	  done
endef

##
# normalise_dirname
#   $1 - A directory name which may or may not be terminated with a
#        slash ('/') character
# Return the directory name definitely terminated with a single slash.
#
normalise_dirname = $(strip $(subst //,/,$1/))

##
# sketch_files
#   $1 - list of compiled (object or dep) files, some of which may be
#        lib files, corelib files or sketch files.
# Return only the files that are directly part of the sketch.  Since
# other files will be compiled into target directories below
# BUILD_DIR, we can identify sketch files as those that are compiled
# directly into BIULD_DIR.
#
sketch_files = $(strip \
		 $(foreach path,$1,\
	           $(if $(call eq,$(call normalise_dirname,$(dir $(path))),\
				  $(call normalise_dirname,$(BUILD_DIR))),\
		       $(path))))

##
# lib_files
#   $1 - list of compiled (object or dep) files, some of which may be
#        lib files or sketch files.
# Return only the files that are lib files.  In order to identify lib
# files only and not corelib files, $1 should not contain corelib files.
#
lib_files = $(strip $(call minus,$1,$(call sketch_files,$1)))

##
# core_files
#   $1 - list of compiled (object or dep) files, some of which may be
#        lib files or sketch files.
# Return only the files that are corelib files. 
#
core_files = $(strip \
		 $(foreach path,$1,\
	           $(if $(call eq,$(call normalise_dirname,$(dir $(path))),\
				  $(call normalise_dirname,\
				         $(BUILD_DIR)/libcore)),\
		       $(path))))

##
# requote
# Helper macro to requote lines coming from BOARD_INFO (and friends).
# Any quotes that appear to be within words get escaped.  Others are
# leaved as they are.  This makes most recipes coming from BOARD_INFO
# work.  How they work in the Arduino ide is a mystery as the quoting
# in platform.txt seems very eccentric in places.
#
requote = $(shell echo '$1' | dno_requote) 

##
# indent
# This indents command output to help make it more readable.
#
indent = set -o pipefail; ($1) | sed -e 's/^/    /'


# STARTDIR is set when we are recursinf for one of the clean targets.
# In these cases we just want to get started as quickly as possible,
# so we avoid much of the slow startup bahaviour.
#
ifdef STARTDIR
  QUICKSTART = true
endif

ifndef QUICKSTART

################################################################
# Figure out from where we are being run.
#
# dno_dirinfo is used to determine where we are in an Arduino development
# directory system.
#
# Generally, the default target will depend on where we are.  If we are in a
# code directory, the default target will build the code.  If in a lib or unit
# test directory, it will build and run unit tests.  If in a docs directory,
# it will build docs.
#

# A local dno.mk file can be used to override or redefine certain
# variables.  In particular DIR_TYPE can be defined rather than
# allowing it to be dynamically discovered.
#
-include dno.mk

ifndef DIR_TYPE
  DIR_TYPE = $(shell $(BINDIR)/dno_dirinfo)
endif

BUILD_TYPE = unknown
BOARD_DIR = .

# Certain targets do not need the dependency files.  In fact those files can
# get in the way (eg for the clean targets).  This definition allows those
# targets to work without attempting to refresh the dependency files.
#
NO_DEP_TARGETS = clean tidy pristine \
		 do_clean do_tidy do_pristine \
		 list info help show_boards \
		 BOARD_TYPE BOARD_INFO dno_board_type

# ONLY_NODEP_TARGETS is true (has a value) if all of the command line
# targets appear in NO_DEP_TARGETS
#
ONLY_NODEP_TARGETS = $(and $(MAKECMDGOALS),\
	   $(call not,$(call minus,$(MAKECMDGOALS),$(NO_DEP_TARGETS))))

# Define some fundamental variables based on the type of our directory tree
# and whether targets have been explicitly specified.
#
ifeq "$(findstring _board, $(DIR_TYPE))" "_board"
  BUILD_TYPE = build
  CROSS_BUILD = yes
  BOARD_DIR = .
  ifeq "$(DIR_TYPE)" "sub_board"
    PROJDIR = ..
    SRC_DIRS = . ..
    USER_LIB_ROOTS = . ..
  else
    PROJDIR = .
    SRC_DIRS = .
    USER_LIB_ROOTS = .
  endif
else ifeq "$(DIR_TYPE)" "root_code"
  BUILD_TYPE = root_code_info
  BOARD_DIR = .
  PROJDIR = .
  USER_LIB_ROOTS = .
else ifeq "$(DIR_TYPE)" "root"
  BUILD_TYPE = root_build_info
  PROJDIR = .
  BOARD_DIR = .
  USER_LIB_ROOTS = .
else ifeq "$(DIR_TYPE)" "test"
  BUILD_TYPE = unit_test
  PARENT = $(shell $(BINDIR)/dno_dirinfo ..)
  ifeq "$(PARENT)" "lib"
    TEST_LIB = $(notdir $(realpath ..))
    TEST_LIB_DIR = ../../$(TEST_LIB)
    TEST_CODE_DIR = .
    GPARENT = $(shell $(BINDIR)/dno_dirinfo ../..)
    ifeq "$(findstring root, $(GPARENT))" "root"
      PROJDIR = ../..
      USER_LIB_ROOTS = ../.. 
    else
      PROJDIR = ../../..
      USER_LIB_ROOTS = ../.. ../../.. 
    endif
  else
    $(error NOT IMPLEMENTED: HANDLING FOR TEST PARENT $(PARENT))
  endif
  NATIVE_BUILD = yes
else ifeq "$(DIR_TYPE)" "lib"
  BUILD_TYPE = lib
  ifeq "$(shell $(BINDIR)/dno_dirinfo ..)" "root"
    PROJDIR = ..
  else
    ifeq "$(shell $(BINDIR)/dno_dirinfo ../..)" "root"
      PROJDIR = ../..
    else
      $(error CANNOT DETERMINE TYPE OF DIRECTORY)
    endif
  endif
else ifeq "$(DIR_TYPE)" "docs"
  BUILD_TYPE = docs
  DIR_TYPE = $(shell $(BINDIR)/dno_dirinfo ..)
else
  BOARD_DIR = .
endif

# If all of our targets are NODEP_TARGETS, then we don't want to do a
# build which might attempt to refresh our dep files.
#
ifeq '$(ONLY_NODEP_TARGETS)' 't'
    CROSS_BUILD =
    NATIVE_BUILD =
endif

PROJDIR := $(abspath $(PROJDIR))

$(call debug,NATIVE_BUILD)
$(call debug,PROJDIR)
$(call debug,BUILD_TYPE)
$(call debug,DIR_TYPE)
$(call debug,BOARD_DIR)
$(call debug,BUILD_DIR)

ifndef STARTDIR
  STARTDIR = $(CURDIR)
endif
$(call debug,STARTDIR)


################################################################
# Default target
# This must appear before any other targets.  The value of BUILD_TYPE
# is determined by the type of directory in which we are called.
#
$(BUILD_TYPE):


################################################################
# build hook targets
# Note that some hooks are implemented directly within other targets
#
#
.PHONY: prebuild presketch postsketch precore

# Note that $(object_files) is actually a proxy for "the files that
# need to be built.  Make believes it has built these files, but
# actually they will be built when the equivalent .d files are built.
# By doing this, we can ensure that prebuild is always run when we
# have sketch or library files to be compiled.  
#
prebuild: $(object_files) BOARD_INFO
	$(TARGET)
	@# $(eval COMMANDS = \
	     $(and $(WILL_COMPILE),$(shell dno_commands_for prebuild)))
	@$(and $(COMMANDS),$(FEEDBACK_RAW) Performing pre-build...)
	$(AT) $(and $(COMMANDS), $(call indent,$(COMMANDS)))
	@rm -f $(BUILD_DIR)/.prelib \
		$(BUILD_DIR)/.presketch 2>/dev/null || true

presketch: prebuild BOARD_INFO 
	$(TARGET)
	@#echo presketch[$(MAKE_RESTARTS)] deps: $?
	@#echo WC: $(WILL_COMPILE)
	@#echo "SF(WC):" $(call sketch_files,$(WILL_COMPILE))
	@# $(eval COMMANDS = \
	     $(and $(call sketch_files,$(WILL_COMPILE)),\
		   $(shell dno_commands_for sketch.prebuild)))
	@$(and $(COMMANDS), $(FEEDBACK_RAW) Performing sketch pre-build...)
	$(AT) $(and $(COMMANDS), $(call indent,$(COMMANDS)))
	@$(and $(COMMANDS), touch $(BUILD_DIR)/.presketch)

postsketch: presketch
	$(TARGET)
	@#echo postketch[$(MAKE_RESTARTS)] deps: $?
	@# $(eval COMMANDS = \
	     $(and $(wildcard $(BUILD_DIR)/.presketch),\
		   $(shell dno_commands_for sketch.postbuild)))
	@$(and $(COMMANDS), $(FEEDBACK_RAW) Performing sketch post-build...)
	$(AT) $(and $(COMMANDS), $(call indent,$(COMMANDS)))
	@rm -f $(BUILD_DIR)/.presketch

prelib: postsketch 
	$(TARGET)
	@#echo prelib[$(MAKE_RESTARTS)] deps: $?
	@##echo WC: $(WILL_COMPILE)
	@# $(eval COMMANDS = \
	     $(and $(call not,$(wildcard $(BUILD_DIR)/.prelib)),\
		   $(call lib_files,$(WILL_COMPILE)),\
		   $(shell dno_commands_for libraries.prebuild)))
	@$(and $(COMMANDS), $(FEEDBACK_RAW) Performing lib pre-build...)
	$(AT) $(and $(COMMANDS), $(call indent,$(COMMANDS)))
	@$(and $(COMMANDS), touch $(BUILD_DIR)/.prelib)

postlib: prelib
	$(TARGET) 
	@#echo postlib[$(MAKE_RESTARTS)] deps: $?
	@# $(eval COMMANDS = \
	     $(and $(wildcard $(BUILD_DIR)/.prelib),\
		   $(shell dno_commands_for libraries.postbuild)))
	@$(and $(COMMANDS), $(FEEDBACK_RAW) Performing lib post-build...)
	$(AT) $(and $(COMMANDS), $(call indent,$(COMMANDS)))
	@rm -f $(BUILD_DIR)/.prelib

precore: postsketch postlib
	$(TARGET)
	@#echo precore[$(MAKE_RESTARTS)] deps: $?
	@# $(eval COMMANDS = \
	     $(and $(call not,$(wildcard $(BUILD_DIR)/.precore)),\
		   $(call core_files,$(WILL_COMPILE)),\
		   $(shell dno_commands_for core.prebuild)))
	@$(and $(COMMANDS), $(FEEDBACK_RAW) Performing core pre-build...)
	$(AT) $(and $(COMMANDS), $(call indent,$(COMMANDS)))
	@$(and $(COMMANDS), touch $(BUILD_DIR)/.precore)


################################################################
# Callable build rule generators
#

##
# Compilation rules for unit test compilations.  This creates the rules for
# compiling cpp, c and S files.
#
# $1 is the target directory for objects
# $2 is the source directory
# $3 is the optional lib name
#
define NATIVE_COMPILE_RULE
$(1)/%.o $(1)/%.d &: $(2)/%.cpp
	$$(TARGET)
	@mkdir -p $$(dir $$@)
	$(FEEDBACK)  C++ $(if $3,[$3]) $$(notdir $$<)
	$(AT) $$(CXX) $$(CXXFLAGS) -c -MMD $$< -o $$(@:.d=.o)
$(1)/%.o $(1)/%.d &: $(2)/%.c
	$$(TARGET)
	@mkdir -p $$(dir $$@)
	$(AT) $$(CC) $$(CFLAGS) -c -MMD $$< -o $$(@:.d=.o)
	false
$(1)/%.S.o $(1)/%.S.d &: $(2)/%.S
	$$(TARGET)
	@mkdir -p $$(dir $$@)
	$(FEEDBACK)  NOT IMPLEMENTED: AS $$<
	false

endef

# Eval'able rule definition for compiling C++, C, INO and ASM sources
# for different arduino-like boards.
# $1 is the path to the object file.
# $2 is the path to the source file.
# $3 is a short printable version  of $2, for feedback.
# $4 is a dependency provider function
# Note that the ino rule creates a strangely named file.  This is for
# compatibility with the standard ide stuff, even though it sucks.
#
define CROSS_COMPILE_RULE
$(1)/%.ino.d: $(2)/%.ino BOARD_INFO $4
	$$(TARGET)
	$(FEEDBACK)  "C++  $(if $3,[$3],[$$(dir $$<)]) $$(notdir $$<)"
	$(AT) $$(call requote,$$(recipe.ino.o.pattern))
$(1)/%.d: $(2)/%.cpp BOARD_INFO $4
	$$(TARGET)
	$(FEEDBACK)  "C++  $(if $3,[$3],[$$(dir $$<)]) $$(notdir $$<)"
	$(AT) $$(call requote,$$(recipe.cpp.o.pattern))
$(1)/%.d: $(2)/%.c BOARD_INFO $4
	$$(TARGET)
	$(FEEDBACK)  "C  $(if $3,[$3],[$$(dir $$<)]) $$(notdir $$<)"
	$(AT) $$(call requote,$$(recipe.c.o.pattern))
$(1)/%.S.d: $(2)/%.S BOARD_INFO $4
	$$(TARGET)
	$(FEEDBACK)  "AS  $(if $3,[$3],[$$(dir $$<)]) $$(notdir $$<)"
	$(AT) $$(call requote,$$(recipe.S.o.pattern))
$(1)/%.ino.o: $(2)/%.ino BOARD_INFO 
	$$(TARGET)
	@# $$(eval WILL_COMPILE += $$@)
$(1)/%.o: $(2)/%.cpp BOARD_INFO
	$$(TARGET)
	@# $$(eval WILL_COMPILE += $$@)
$(1)/%.o: $(2)/%.c BOARD_INFO
	$$(TARGET)
	@# $$(eval WILL_COMPILE += $$@)
$(1)/%.S.o: $(2)/%.S BOARD_INFO
	$$(TARGET)
	@# $$(eval WILL_COMPILE += $$@)

endef

# Rule for building arduino .a files.
# $1 is the full pathname of the archive
# $2 is the set of objects to go in to the archive
#
define CROSS_ARCHIVE_RULE
$1: $2
	$$(TARGET)
	$$(FEEDBACK) AR [$$(basename $$(notdir $$@))] $$(notdir $$<)...
	$$(AT) $$(compiler.path)$$(compiler.ar.cmd) rcs $$@ $$^
	@# $(eval COMMANDS = $(shell dno_commands_for core.postbuild))
	@$(and $(COMMANDS),$(FEEDBACK_RAW) Performing post-core...)
	$(AT) $(and $(COMMANDS),$(call indent,$(COMMANDS)))

endef

# Macro for declaring dependencies.  This is called and then eval'd in
# order to dynamically create dependencies.
# 
define DEPENDENCY_RULE
$1: $2

endef

# Macro for defining executable lines within recipes.
#
define RECIPE_LINE

	$$(AT) $$($1)
endef

# Define build rules for given source directories updating DEPS, our list of
# generated dependency files, as we go.  Note that this is a recursive macro
# which needs to be evaluated in order to actually create the rules.
#
# The feedback macro calls below provide feedback when SHOW_RULES is defined.
#   $1 - the name of the compile rule macro
#   $2 - the target directory for objects
#   $3 - the prioritised list of source directories
#   $4 - lib paths (where to search for libraries)
#   $5 - optional lib shortname to pass to out compile_rules
#   $6 - optional dependencies to pass into our initial compile_rule
#   $7 - optional dependents function to call after our initial compile_rule
#   $8 - optional dependencies to pass into our subsequent compile_rules
#   $9 - optional dependents function to call after our subsequent compile_rules
#
define ALL_BUILD_RULES
  $(shell mkdir -p $2)
  RULE_SOURCES := $$(call uniqify,\
		          $$(call matching_files,*.ino *.cpp *.c *.S, $3),\
	                  filepart)
  RULE_DEPS := $$(patsubst %.o,%.d,$$(call to_objects,$2,$$(RULE_SOURCES)))
  RULE_DIRS := $$(sort $$(dir $$(RULE_SOURCES)))
  $$(call feedback,$(space) RULE_DIRS: $$(RULE_DIRS))
  $$(call feedback,$(space) RULE_SOURCES: $$(RULE_SOURCES))
  $$(foreach dir,$$(RULE_DIRS),\
    $$(call feedback,$$(call $1,$2,$$(dir),\
	    $$(or $5,$$(call libname,$$(dir))),$6))\
    $$(eval $$(call $1,$2,$$(dir),$$(or $5,$$(call libname,$$(dir))),$6)))

  $$(call $7,$$(RULE_DEPS))
  $$(eval ALL_DEPS += $$(RULE_DEPS))
  $$(call feedback,$(space) INCLUDING: $$(RULE_DEPS))
  include $$(RULE_DEPS)

  $$(foreach libdir,$$(foreach dir,$4,$$(call deplibs,$$(dir),$$(RULE_DEPS))),\
    $$(foreach lib,$$(call libname,$$(libdir)),\
      $$(if $$(filter-out $$(REQUIRED_LIBS), $$(lib)),\
        $$(eval REQUIRED_LIBS += $$(lib))\
          $$(eval $$(call ALL_BUILD_RULES,$1,$2/$$(lib),\
			  $$(libdir),$$4,$5,$8,$9,$8,$9)))))
endef

sketch_deps = $(call feedback,$(call DEPENDENCY_RULE,prebuild presketch,$(1:.d=.o)))\
	      $(eval $(call DEPENDENCY_RULE,prebuild presketch,$(1:.d=.o)))\
              $(call feedback,$(call DEPENDENCY_RULE,postsketch,$1))\
              $(eval $(call DEPENDENCY_RULE,postsketch,$1))

lib_deps = $(call feedback,$(call DEPENDENCY_RULE,prelib,$(1:.d=.o)))\
	   $(eval $(call DEPENDENCY_RULE,prelib,$(1:.d=.o)))\
           $(call feedback,$(call DEPENDENCY_RULE,postlib,$1))\
           $(eval $(call DEPENDENCY_RULE,postlib,$1))

core_deps = $(call feedback,$(call DEPENDENCY_RULE,precore,$(1:.d=.o)))\
	    $(eval $(call DEPENDENCY_RULE,precore,$(1:.d=.o)))


################################################################
# Discovery of source files and dynamic creation of build rules.
#

ifeq "$(CROSS_BUILD)" "yes"
  # We are doing a cross-build, ie compiling for a different
  # architecture than the host.  This is the normal type of arduino
  # build.
  CONFIG_FILES = BOARD_INFO $(wildcard BOARD_OPTIONS)
  include $(CONFIG_FILES)
  ifdef  recipe.cpp.o.pattern
    # We only do the following if BOARD_INFO was successfully read.
    # This prevents a load of half-baked things happening in the event
    # that we are going to have to restart dno after building BOARD_INFO
    PROJNAME = $(notdir $(realpath $(PROJDIR)))
    ifneq "$(PROJNAME)" "$(build.project_name)"
      # Project dirname has changed.  Force a rebuild of BOARD_INFO
      BI_DEPS := FORCE
    else
      BI_DEPS :=
    endif

    # Identify possible libraries.
    USER_LIB_DIRS = $(foreach root,$(USER_LIB_ROOTS),\
		      $(call is_lib,$(wildcard $(root)/*)))
    STD_LIB_DIRS = $(call is_lib,$(wildcard $(dir $(BOARD_FILE))/libraries/*))
    ALL_LIB_DIRS = $(call uniqify,$(USER_LIB_DIRS) $(STD_LIB_DIRS),libname)
    ALL_LIB_FLAGS = $(foreach dir,$(ALL_LIB_DIRS),-I $(dir))
    CXXFLAGS += $(ALL_LIB_FLAGS)
    CXXFLAGS += -Os -Wall

    build.menu_selections = :$(shell dno_menu -l)

    $(call debug,STD_LIB_DIRS)
    $(call debug,ALL_LIB_DIRS)

    # This is a hack to make compilation of ino files work.  The arduino
    # ide way of dealing with .ino files is so dumb that I cannot
    # bear to even think about trying to replicate it, so:
    # tweak the provided cpp compiler rule to make an ino compiler rule.
    #
    ino_compiler_flags = -x c++ --include Arduino.h
    recipe.ino.o.pattern = $(subst \
      $(compiler.cpp.cmd)",$(compiler.cpp.cmd)" $(ino_compiler_flags),\
      $(recipe.cpp.o.pattern))

    # define a pattern for uploading eeprom files.  Don't know why
    # this is not already defined.
    #
    recipe.eep.upload.pattern = \
	        $(subst flash:w,eeprom:w,\
		        $(subst .hex:i,.eep:i,\
				$(tools.$(upload.tool).upload.pattern))))

    source_file = $<
    object_file = $(@:.d=.o)
    build.path = $(BUILD_DIR)
    build.core.path = $(realpath $(runtime.platform.path)/cores/$(build.core))
    includes = -I $(build.core.path) -I $(build.variant.path) \
	       $(ALL_LIB_FLAGS)
    archive_file = libcore.a
    archive_file_path = $(build.path)/$(archive_file)

    WILL_COMPILE :=
    REQUIRED_LIBS :=
    ALL_DEPS :=
    $(eval $(call ALL_BUILD_RULES,CROSS_COMPILE_RULE,\
		$(BUILD_DIR),$(SRC_DIRS),$(ALL_LIB_DIRS),,\
		| presketch,sketch_deps,\
		| prelib,lib_deps))

    $(call debug,REQUIRED_LIBS)
    $(call debug,ALL_DEPS)
    object_files := $(ALL_DEPS:.d=.o)

    ifeq "$(strip $(call unbuilt_deps,$(ALL_DEPS)))" ""
      # All Dependency files have been created.  We can now
      # define the build rules for libcore.  We make this conditional as
      # this makefile may restart multiple times as library
      # dependencies are resolved, and we don't want to create the rules
      # for the core objects until last.

      $(eval $(call ALL_BUILD_RULES,CROSS_COMPILE_RULE,\
		$(BUILD_DIR)/libcore,$(build.core.path),,core,\
		| precore,core_deps))
      CORE_OBJECTS = $(foreach obj,\
			     $(notdir $(call core_files,$(ALL_DEPS:.d=.o))),\
	             build/libcore/$(obj))
      $(call feedback,$(call CROSS_ARCHIVE_RULE,$(archive_file_path),\
		      $(CORE_OBJECTS)))
      $(eval $(call CROSS_ARCHIVE_RULE,$(archive_file_path),$(CORE_OBJECTS)))
    endif

    TARGET_NAME = $(PROJNAME)
    ifeq "${recipe.objcopy.hex.pattern}" ""
      TARGET_HEX = 
    else
      TARGET_HEX = $(BUILD_DIR)/$(TARGET_NAME).hex
    endif
    ifeq "${recipe.objcopy.bin.pattern}" ""
      TARGET_BIN = 
    else
      TARGET_BIN = $(BUILD_DIR)/$(TARGET_NAME).bin
    endif

    TARGET_ELF = $(BUILD_DIR)/$(TARGET_NAME).elf
    TARGET_EEP = $(BUILD_DIR)/$(TARGET_NAME).eep
    $(call debug,TARGET_ELF)
    $(call debug,TARGET_BIN)
    $(call debug,TARGET_HEX)
      OBJCOPY_PATTERNS := $(call uniqify,\
        $(shell grep "^recipe.objcopy\..*\.pattern=" BOARD_INFO | cut -d= -f1))

    ifneq ($(strip $(upload.maximum_size)),)
      CHECK_SIZE = $(recipe.size.pattern) | $(BINDIR)/dno_checksize \
          MAX_DATA=$(upload.maximum_data_size) \
          MAX_UPLOAD=$(upload.maximum_size)
    else
      CHECK_SIZE = echo "Cannot determine flash memory of $(BOARD_TYPE).";\
                   echo "Make sure the size of $(TARGET_ELF) is" \
                        "less than $(BOARD_TYPE)'s flash memory"
    endif

  endif
else ifeq "$(NATIVE_BUILD)" "yes"
  # This is for compiling and building unit tests.  We are using the host's
  # native compiler rather than a special cross-compiler.

  TEST_EXECUTABLE = $(BUILD_DIR)/$(notdir \
	              $(basename $(wildcard $(TEST_CODE_DIR)/test_*cpp)))
  PROJNAME = $(TEST_LIB)

  PROJ_LIB_DIRS = $(foreach dir,\
		    $(shell find $(PROJDIR) -maxdepth 2 -name Arduino.h \
		            -exec dirname '{}' \;),\
		    $(if $(shell dno_dirinfo $(dir) | \
				     grep test_container),$(dir)))
  # STUBBED_LIBS gives us the names of libraries we have stubbed for testing.
  # This enables us to eliminate the real libraries from the build.
  #
  STUBBED_LIBS := $(patsubst %.h,./%,\
	            $(notdir $(wildcard $(PROJ_LIB_DIRS)/*.h) $(wildcard *.h)))

  USER_LIB_DIRS := $(subst $(strip $(STUBBED_LIBS)),,\
                      $(strip \
		        $(call uniqify, $(STUBBED_LIBS) $(TEST_LIB_DIR) \
		          $(foreach root,$(USER_LIB_ROOTS),\
		            $(call is_lib,$(wildcard $(root)/*))),libname)))
  ALL_LIB_DIRS := $(USER_LIB_DIRS) $(PROJ_LIB_DIRS) \
		  $(STD_LIB_DIRS) $(USER_LIB_ROOTS)
  CXXFLAGS += -g -O0 -Wall -DUNIT_TESTING -I . \
		$(foreach dir,$(ALL_LIB_DIRS),-I $(dir))

  $(eval $(call ALL_BUILD_RULES,NATIVE_COMPILE_RULE,\
	        $(BUILD_DIR),$(TEST_CODE_DIR),$(ALL_LIB_DIRS)))
  TEST_OBJECTS := $(patsubst %.d, %.o, $(ALL_DEPS))
  MAIN_TEST_OBJECT = $(TEST_EXECUTABLE).o
  SECONDARY_TEST_OBJECTS = $(call minus,$(TEST_OBJECTS),$(MAIN_TEST_OBJECT))
else ifeq "$(BUILD_TYPE)" "lib"
  TESTDIR = $(foreach dir,$(shell find . -maxdepth 1 -mindepth 1 -type d),\
	      $(firstword $(or $(filter %/test,${dir}),\
			       $(filter %/tests,${dir}),\
			       $(filter %/unit,${dir}))))
else
  PROJNAME = $(notdir $(realpath $(PROJDIR)))
endif

$(call debug,PROJNAME)
$(call debug,PROJDIR)


################################################################
# BOARD_INFO and related targets
#

.PHONY: show_boards install_extra_boards show_extra_boards FORCE

# Define the BPP, board and platforms parser, command.
#
BPP = $(BINDIR)/dno_bpp

DIRNAME = $(notdir $(realpath $(BOARD_DIR)))

# Figure out the dependencies to allow BOARD_INFO to be built based on
# dirname, BOARD_TYPE, or the value of our BOARD variable.
#
ifneq "$(BOARD)" ""
  # BOARD has been provided as a parameter
  BI_DEPS += BOARD_TYPE
  BT_DEPS += FORCE
  # Parameters for board and cpu type can be derived from BOARD and CPU
  # definitions provided on the command line.  Provide these to the BOARD_TYPE
  # target, to create a BOARD_TYPE file.
  #
  BOARD_TYPE_PARAMS = `[ "x$(BOARD)" = "x" ] || echo "-b $(BOARD)"`
  CPU_TYPE_PARAMS = `[ "x$(CPU)" = "x" ] || echo "-c $(CPU)"`
else
  BOARD_TYPE := $(wildcard BOARD_TYPE)
  ifeq "$(BOARD_TYPE)" ""
    # We have no BOARD_TYPE file.  Let's see if our directory name
    # specifies a valid board type.
    BOARD != $(BPP) -b $(DIRNAME) -t
    ifeq "$(.SHELLSTATUS)" "0"
      # Directory name looks valid.  Check that it matches our BOARD_INFO
      BOARD_INFO := $(wildcard BOARD_INFO)
      ifneq "$(BOARD_INFO)" ""
        # BOARD_INFO file exists.  Check if it matches our BOARD
	BOARD_FROM_INFO != sed -n -e '/^BOARD_TYPE/{s/.*=\s//p}' BOARD_INFO
        ifneq "$(BOARD)" "$(BOARD_FROM_INFO)"
	  # We need to rebuild BOARD_INFO (else nothing to do)
	  BI_DEPS += FORCE
	endif
      endif
    else
      # Dirname is not valid.  BOARD_INFO build needs to fail, so make
      # it depend on BOARD_TYPE
      BI_DEPS += BOARD_TYPE
      BOARD := unknown
    endif
  else
   # We have a BOARD_TYPE_FILE
   BI_DEPS += BOARD_TYPE
   BOARD := $(file < BOARD_TYPE)
  endif
endif

# Identify any platform.local.txt file: this will be a dependency for
# BOARD_INFO iff it exists.  Note that dno allows platform.local.txt
# to be placed in a code directory, where it will take prcedence over
# any other.
#
PLATFORM_LOCAL := $(firstword \
		    $(foreach dir,$(SRC_DIRS),\
		               $(wildcard $(dir)/platform.local.txt))\
		    $(wildcard $(dir $(PLATFORM_FILE))/platform.local.txt))
$(call debug,PLATFORM_LOCAL)

# Special target to be added as a dependency to force dependent
# targets to be rebuilt.
#
FORCE:

# BOARD_INFO contains definitions needed by make to perform the
# various compilations, links, uploads, etc.  These definitions are
# specific to the chosen board-type which may be determined from a
# BOARD_TYPE file or the name of the current directory.
#

BOARD_INFO: $(BI_DEPS) $(PLATFORM_LOCAL) \
	    $(BOARD_FILE) $(PLATFORM_FILE)
	$(TARGET)
	$(FEEDBACK) Creating $@...
	$(AT)if $(BPP) -b $(BOARD) -p >$@2; then \
	    mv $@2 $@; \
	else \
	    rm -f $@2; false; fi

# BOARD_TYPE identifies the type of board that we will be creating
# images for.  In its absence the name of the current directory may
# provide the board type.
#
BOARD_TYPE: $(BT_DEPS)
	$(TARGET)
	$(FEEDBACK) Creating $@...
	$(AT) $(BPP) $(BOARD_TYPE_PARAMS) $(CPU_TYPE_PARAMS) -t >$@ || \
	    (rm $@; \
	     echo "Unable to create $@.  Try dno help" 1>&2; \
	     false)

# Install another boards.txt to your user environment.  You need to
# define BOARDS_PATH on the command line, which must be the full path
# to a boards.txt file."
#
install_extra_boards:
	$(TARGET)
	$(AT) [ -f $(BOARDS_PATH) ] || \
	      [ -f $(BOARDS_PATH)/boards.txt ] || \
	      (echo "BOARDS_PATH must be defined and be the path" \
	            "to a boards.txt file." 1>&2; exit 2)
	$(AT) if [ "x$(notdir $(BOARDS_PATH))" = "xboards.txt" ]; then \
	    echo "$(dir $(BOARDS_PATH))" >>$(EXTRA_BOARDS_FILE); \
	else \
	    echo "$(BOARDS_PATH)" >>$(EXTRA_BOARDS_FILE); \
	fi

show_extra_boards:
	$(TARGET)
	@if [ -f $${HOME}/.dno_boards_paths ]; then \
	    echo "Supplemental boards.txt directories:"; \
	    sed -e 's/#.*//' -e 's/^/  /' $(EXTRA_BOARDS_FILE) | \
	        grep '[^[:space:]]'; \
	else \
	    echo "No supplemental boards.txt directories defined."; \
	fi

# List all supported boards.  You can narrow down the shown options by
# specifying BOARD and/or CPU on the command line.
#
show_boards:
	$(TARGET)
	$(AT) echo
	$(AT) echo "    Supported ArduinoBoard and CPU Types"
	$(AT) echo ============================================================
	$(AT) $(BPP) -f $(BOARD_TYPE_PARAMS) $(CPU_TYPE_PARAMS) || true


################################################################
# Major targets
#

.PHONY: build root_code_info root_build_info lib unit_test \
	test tests unit size verify_size

build: BOARD_INFO $(TARGET_HEX) $(TARGET_BIN) $(TARGET_ELF)

ifeq "$(CROSS_BUILD)" "yes"
$(TARGET_EEP): $(TARGET_ELF) BOARD_INFO 
	$(TARGET)
	$(FEEDBACK) OBJCOPY "(eep)" $(notdir $<)
	$(AT) ${recipe.objcopy.eep.pattern}

$(TARGET_HEX): $(TARGET_ELF) 
	$(TARGET)
	@# $(eval COMMANDS = $(shell dno_commands_for savehex.presavehex))
	@$(and $(COMMANDS),$(FEEDBACK_RAW) Performing pre-savehex...)
	$(AT) $(and $(COMMANDS),$(call indent,$(COMMANDS)))
	$(FEEDBACK) OBJCOPY "(hex)" $(notdir $<)
	$(AT) ${recipe.objcopy.hex.pattern}
	@# $(eval COMMANDS2 = $(shell dno_commands_for savehex.postsavehex))
	@$(and $(COMMANDS2),$(FEEDBACK_RAW) Performing post-savehex...)
	$(AT) $(and $(COMMANDS2),$(call indent,$(COMMANDS2)))

# BIN_TARGET_RECIPE is eval'd to define the $(TARGET_BIN) recipe.
# Note that a RECIPE_LINE entry in the form:
#   <tab>$$(AT) $$(<objcopy recipe name>)
# is created for each entry in OBJCOPY_PATTERNS.  The need to do this
# is why we eval this definition rather than simply placing it
# verbatim below.
#
define BIN_TARGET_RECIPE
$(TARGET_BIN): $(TARGET_ELF) 
	$$(TARGET)
	@# $$(eval COMMANDS = $$(shell dno_commands_for objcopy.preobjcopy))
	@$$(and $$(COMMANDS),$$(FEEDBACK_RAW) Performing pre-objcopy...)
	$$(AT) $$(and $$(COMMANDS),$$(call indent,$$(COMMANDS)))
	$$(FEEDBACK) OBJCOPY "(bin)" $(notdir $$<)
	$$(AT) $$(recipe.objcopy.bin.pattern)
	@#$(foreach pattern,$(OBJCOPY_PATTERNS),$(call RECIPE_LINE,$(pattern)))
	@# $$(eval COMMANDS2 = $$(shell dno_commands_for objcopy.postobjcopy))
	@$$(and $$(COMMANDS2),$$(FEEDBACK_RAW) Performing post-objcopy...)
	$$(AT) $$(and $$(COMMANDS2),$$(call indent,$$(COMMANDS2)))

endef
$(call feedback, BIN_TARGET_RECIPE $(call BIN_TARGET_RECIPE))
$(eval $(call BIN_TARGET_RECIPE))

# If files for ctags or etags are found, they become a dependency of
# our elf target, so that they get automatically updated as needed.
#
TAGFILES = $(wildcard TAGS) $(wildcard tags)

$(TARGET_ELF): $(object_files) $(archive_file_path) $(TAGFILES) BOARD_INFO
	$(TARGET)
	@# $(eval COMMANDS = $(shell dno_commands_for linking.prelink))
	@$(and $(COMMANDS),$(FEEDBACK_RAW) Performing pre-link...)
	$(AT) $(and $(COMMANDS),$(call indent,$(COMMANDS)))
	$(FEEDBACK) LD $(notdir $(object_files))
	$(AT) $(recipe.c.combine.pattern)
	@# $(eval COMMANDS2 = $(shell dno_commands_for linking.postlink))
	@$(and $(COMMANDS2),$(FEEDBACK_RAW) Performing post-link...)
	$(AT) $(and $(COMMANDS2),$(call indent,$(COMMANDS2)))



size:   $(TARGET_ELF)
	$(TARGET)
	@echo size
	$(AT) $(CHECK_SIZE)

verify_size:   $(TARGET_ELF)
	$(TARGET)
	$(AT) $(CHECK_SIZE) >/dev/null

endif

root_code_info root_build_info:
	$(TARGET)
	@echo "Nothing to be done here (in `pwd`)."
	@echo "Try dno ./BOARD_TYPE or dno tests"

lib:
	$(TARGET)
	$(AT)if [ "x$(strip $(TESTDIR))" = "x" ]; then\
	    echo "Nothing to be done here (in `pwd`)." \
		 " $(PROJ_DIR) Try creating unit tests.";\
	 else \
	    cd $(TESTDIR) && \
	        $(MAKE); \
	 fi

ifeq "$(NATIVE_BUILD)" "yes"
# There is no point in defining these rules unless we are in a
# position to run unit tests.

unit_test test tests unit: $(TEST_EXECUTABLE)
	$(TARGET)
	$(FEEDBACK) RUN $(notdir $<)...
	$(AT) $(call indent,$(TEST_EXECUTABLE))
	$(FEEDBACK) "...DONE ($(notdir $<))"
	@echo

$(TEST_EXECUTABLE): $(TEST_OBJECTS) $(TAGFILES) 
	$(TARGET) $(TEST_OBJECTS)
	$(FEEDBACK)  LD [$(notdir $@)]
	$(AT) g++ $(LDFLAGS) -o $@ $(MAIN_TEST_OBJECT) \
		$(SECONDARY_TEST_OBJECTS)

else
# Identify possible unit test directories
#
TEST_DIRS = $(shell find . -maxdepth 2 -type d -a \
	\( -name tests -o -name test -o -name unit \))

# Identify commands to be run for each unit test directory
#
test_cmds = $(foreach dir,$(TEST_DIRS),\
                (cd $(dir); $(MAKE) test); )

# Run unit tests for all libs
unit_test test tests unit:
	@$(test_cmds)

endif


################################################################
# documentation targets
# Build documentation files using Doxygen.
#
.PHONY: docs

docs/html: $(DOC_SOURCES) docs/Doxyfile
	$(TARGET)
	@rm -rf html/*
	@$(FEEDBACK) "DOXYGEN $(PROJNAME)"
	$(AT)env PROJNAME="$(PROJNAME)" doxygen docs/Doxyfile || \
	  (echo "Doxygen fails: is it installed?"; exit 2)
	@touch $@

docs:
	$(TARGET)
	@if [ "x`dno_dirinfo`" = "xdocs" ]; then \
	    cd ..; $(MAKE) --no-print-directory docs/html; \
	else \
	    $(MAKE) --no-print-directory docs/html; \
	fi

endif #QUICKSTART

################################################################
# clean targets
# The do_xxx targets do the job without feedback.  The other targets go
# recursively into subdirectories and provide feedback.
#
.PHONY: tidy clean pristine do_clean do_tidy do_pristine

garbage += \\\#*  .\\\#*  *~ 
GENERATED_FILES=doxy.tag

do_tidy:
	$(TARGET)
	$(AT) if [ x`dno_dirinfo` != 'xunknown' ]; then \
	     rm -f $(garbage); fi

tidy:
	$(TARGET)
	$(AT) if [ x`dno_dirinfo` != 'xunknown' ]; then \
	    echo Tidying `pwd` | sed -e 's!$(STARTDIR)!.!'; \
	    $(MAKE) --no-print-directory STARTDIR=$(STARTDIR) do_$@; \
	    $(RECURSE_FOR_SUBDIRS); \
	fi

do_clean:
	$(TARGET)
	$(AT) if [ x`dno_dirinfo` != 'xunknown' ]; then \
	    (rm -rf build 2>/dev/null || true); \
	    (rm -rf html 2>/dev/null || true); \
	    rm -f $(GENERATED_FILES); \
	fi

clean: do_clean do_tidy
	$(TARGET)
	$(AT) if [ x`dno_dirinfo` != 'xunknown' ]; then \
	    echo Cleaning `pwd` | sed -e 's!$(STARTDIR)!.!'; \
	    $(MAKE) --no-print-directory STARTDIR=$(STARTDIR) do_$@; \
	    $(RECURSE_FOR_SUBDIRS); \
	fi

do_pristine: 
	$(TARGET)
	$(AT) if [ x`dno_dirinfo` != 'xunknown' ]; then \
	    (rm BOARD_INFO TAGS tags 2>/dev/null || true); \
	fi

pristine: do_clean do_tidy
	$(TARGET)
	$(AT) if [ x`dno_dirinfo` != 'xunknown' ]; then \
	    echo Super-cleaning `pwd` | sed -e 's!$(STARTDIR)!.!'; \
	    $(MAKE) --no-print-directory STARTDIR=$(STARTDIR) do_$@; \
	    $(RECURSE_FOR_SUBDIRS); \
	fi


################################################################
# menu/options targets
#
.PHONY: menu options

menu options:
	$(AT) dno_menu


################################################################
# Device-handling targets
#
.PHONY: devices check_device_path reset monitor no_screen noscreen upload \
        eeprom_image eeprom do_upload do_eeprom

# Attempt to determine the serial device to use for uploads and monitoring for
# DEVICE_PATH.  This is a best guess.  The caller may provide a definitive
# version of DEVICE_PATH.
#
DEVICE_PATHS = $(wildcard \
		/dev/ttyACM? /dev/ttyUSB? /dev/tty.usbserial* \
		/dev/tty.usbmodem* /dev/tty.wchusbserial*)

ifndef DEVICE_PATH
  DEVICE_PATH = $(firstword $(DEVICE_PATHS))
endif
serial.port = $(DEVICE_PATH)

# Give DEVICE_PATH a displayable <undefined> value if it is still not defined.
#
ifeq ($(strip $(DEVICE_PATH)),)
  DEVICE_PATH = <undefined>
endif

# List the possible available devices, where an Arduino may be plugged in.
#
devices:
	$(TARGET)
	@echo DEVICES: $(DEVICE_PATHS)

# Check that we have a DEVICE_PATH defined
#
check_device_path:
	$(TARGET)
	@if [ "x$(DEVICE_PATH)" = "x<undefined>" ]; then \
	    echo "\n  ERROR: No DEVICE_PATH provided\n" 1>&2; \
	    exit 2; fi

# Attempt to reset the Arduino on $(DEVICE_PATH).  This assumes that
# ard-reset-arduino is the right tool to use and is available.  If not, you're
# SOL.
#
reset: check_device_path
	$(TARGET)
	$(FEEDBACK) "Resetting device attached to ($(DEVICE_PATH))..."
	$(AT) ard-reset-arduino $(DEVICE_PATH)


# List of possible baud rates.  We look in our code for instances of these
# strings in order to try to find a suitable default.
#
ifndef MONITOR_BAUD
   SPEEDS = 300 1200 2400 4800 9600 14400 19200 28800 38400 57600 115200
   USER_SOURCES = $(call matching_files,*.ino *.cpp *.c *.S, $(SRC_DIRS))
endif

# Figure out the baud rate for our monitor.  If manually provided, we use
# that, otherwise we try to find a string in the code that looks promising,
# otherwise we default to 9600.  This automatic determination of speed on the
# face of it seems like it should be pretty fragile but is suprisingly
# effective.  If we get it wrong, the user can supply it manually.
#
.baud:
	$(TARGET)
	$(AT)if [ "x$(MONITOR_BAUD)" = "x" ]; then \
	  speed=`grep "\($(subst $(space),\|,$(SPEEDS))\)" $(USER_SOURCES) | \
	    head -1 | sed -e 's/[^0-9]*\([0-9][0-9]*\).*/\1/'`; \
	  if [ "x$${speed}" = "x" ]; then \
	    echo 9600; \
	  else \
	    echo $${speed}; \
	  fi; \
	else \
	    echo $(MONITOR_BAUD); \
	fi >$@

# Run a serial monitor in screen.
#
monitor: check_device_path .baud
	$(TARGET)
	@$(FEEDBACK) "Running screen: C-a k to exit"
	$(AT)screen $(DEVICE_PATH) `cat .baud`

# Ensure there is no screen connected to the DEVICE.  Kill the screen if
# KILLSCREEN has been provided.
#
no_screen noscreen:
	$(TARGET)
	@procs=`screen -ls | grep Attached | \
		sed -e 's/^[ \t]*\([0-9]*\).*/\1/'`; \
	screenproc=`for p in $${procs}; do \
	  ps -fp $$p | grep $(DEVICE_PATH); done | awk '{print $$2}'`;	\
	if [ "x$${screenproc}" != "x" ]; then \
	  if [ "x$(KILLSCREEN)" = "x" ]; then \
	    echo "\n  ERROR: monitor is attached to $(DEVICE_PATH)" 1>&2; \
	    echo "    (Try KILLSCREEN=y)" 1>&2; \
	    exit 3; \
	  else \
	    echo "Killing attached screen..."; \
	    scr=`screen -ls | grep "$${screenproc}\." | awk '{print $$1}'`; \
	    screen -S $${scr} -p 0 -X quit; sleep 1; \
	  fi; \
	fi

# Ensure the eeprom file ($(TARGET_HEX)) is built and upload it to the DEVICE.
#
upload:	$(TARGET_HEX) verify_size reset
	$(TARGET)
	$(MAKE) do_upload

# This is used recursively from the upload target in order to separate any
# dependencies for this target from the main dependency graph.  This allows us
# to effectively on-upload actions such as ensuring there is no monitor
# attached to the DEVICE, without that preventing the build of the eeprom
# file.
#
do_upload: no_screen
	$(TARGET)
	$(FEEDBACK)
	$(FEEDBACK) "  Uploading $(notdir $(TARGET_HEX)) to $(DEVICE_PATH)"
	$(AT) $(tools.$(upload.tool).upload.pattern)

eeprom_image: $(TARGET_EEP) 
	$(TARGET)

eeprom:	$(TARGET_EEP) verify_size reset
	$(TARGET)
	$(MAKE) do_eeprom

do_eeprom: no_screen
	$(TARGET)
	$(FEEDBACK) "\n  writing eeprom from $(notdir $(TARGET_EEP))" \
		"using $(DEVICE_PATH)\n"
	$(AT) $(recipe.eep.upload.pattern)


################################################################
# tags
# You only have to explicitly run the ctags or etags target once in
# each directory.  Once the tags file is created, the default build
# will ensure that it is kept up to date.
#
.PHONY: ctags etags

etags: TAGS

TAGS: $(ALL_SOURCES)
	$(TARGET)
	$(FEEDBACK) ETAGS $(wordlist 1,2,$<)...
	$(AT) etags $^

ctags: tags

tags: $(ALL_SOURCES)
	$(TARGET)
	$(FEEDBACK) CTAGS $(wordlist 1,2,$<)...
	$(AT) ctags $^


################################################################
# help targets
#
.PHONY: info help list
info:
	@echo -e "\n\
Dno ($(DNO_VERSION)) (pronounced dee-no) is a make-based system for \
developing\n\
Arduino software.\n\n\
Uusually dno can be run with no parameters and will do the right thing.  When\n\
you want to do something other than the default action, you give dno a\n\
\"target\" (eg dno upload) and it will perform the actions for that target.\n\
Use dno help to get a list of major targets.\n\n\
With dno you can use your favourite editor and simple command-line tools to\n\
develop well-tested and documented, professional-quality Arduino software.\n\n\
Dno uses a dedicated directory called \"$(BUILD_DIR)\" into which all object,\n\
library, executable, etc files are placed.\n\
\n\
Libaries may contain a \"tests\" (or \"test\" or \"unit\") directory into\n\
which unit tests may be placed.  Running dno in the library directory or its\n\
associated test directory will, by default, cause the unit tests to be\n\
compiled and run.  Common files for unit tests may be placed in a \"tests\"\n\
(or \"test\" or \"unit\") directory under the project root directory.\n\
\n\
Code directories may be for a specific board, in which case the directory\n\
name or a BOARD_TYPE file will identify the type of board (use dno BOARD_TYPE\n\
to create this), or may contain subdirectories for specific boards.  This\n\
allows a common codebase to be easily compiled for several boards.  Eg:\n\
\n\
    panel/\n\
    ├── Button\n\
    │   ├── Button.cpp\n\
    │   ├── Button.h\n\
    │   └── tests\n\
    │       ├── Arduino.h\n\
    │       ├── cppunit.h\n\
    │       └── test_Button.cpp\n\
    ├── panel.ino\n\
    ├── pro.8MHzatmega328\n\
    │   └── BOARD_INFO\n\
    └── uno\n\
        └── BOARD_INFO\n\
\n\
This shows a project directory, \"panel\", with a library, \"Button\",\n\
which contains unit tests, and 2 board directories, one for an Arduino Uno,\n\
and one for an 8MHz atmega 328 pro.  The BOARD_INFO files are created\n\
automatically by dno.  To build for the Uno, cd into the uno directory and\n\
run dno.  To build for the Promini, cd to pro.8MHzatmega328 and run dno.\n\
\n\
The board directories can also contain customised versions of the code from\n\
the parent directory and use customised libraries.  These take precedence\n\
over the parent directories' versions.\n" | $${PAGER:-more}

help:
	@echo -e "Usage:\n\
  dno [[target] [VARIABLE=value]]...\n\n\
Major dno commands/targets:\n\
  build          - Build the local arduino code (default target)\n\
  ctags          - Build a tags file from all sources.  Once created\n\
		   this will automatically be kept up to date by\n\
		   default builds (ditto etags)\n\
  devices        - list the devices which may have an Arduino attached\n\
  eeprom         - upload an eeprom image to an attached Arduino.  You\n\
                   may need to define  DEVICE_PATH=<path to serial device>.\n\
  eeprom_image   - create the eeprom image for uploading using eeprom\n\
  etags          - Build a TAGS file from all sources (see also ctags)\n\
  info           - provide a general description of dno\n\
  install_extra_boards\n\
                 - add another boards.txt file for consideration - \n\
                   define the full path to the file using BOARD_PATH=<path>\n\
  help           - provide a summary of the important targets\n\
  list           - list all available targets\n\
  menu           - invoke a menu system to select board options\n\
  monitor        - monitor the serial connection to the Arduino using\n\
                   the linux screen command.  You may need to define\n\
                   DEVICE_PATH=<path to serial device>.  You can also\n\
                   specify the baud rate in MONITOR_BAUD.  Use C-a k\n\
                   to kill screen\n\
  no-screen      - ensure that no screen is attached (see monitor)\n\
                   with KILLSCREEN=y, any connected screen is killed\n\
  options        - invoke a menu system to select board options\n\
  reset          - attempt to reset the connected Arduino.  You may need\n\
                   to define DEVICE_PATH=<path to serial device>\n\
  show_boards    - show the available boards: provide BOARD=xx\n\
                   and/or CPU=yy to narrow down the options\n\
  BOARD_TYPE     - create a BOARD_TYPE file that identifies the board\n\
                   we are developing for.  Define BOARD= and/or CPU= on\n\
                   the command line.\n\
  show_extra_boards\n\
                 - show the current set of extra boards.txt files\n\
  upload         - upload code to the Arduino.  You may need\n\
                   to define DEVICE_PATH=<path to serial device>\n\
\n\
dno can usually be invoked with no targets and will do the right thing based\n\
on the directory it is run from.\n\n\
To increase feedback, define VERBOSE=y on the command line.\n\n\
For more developer information read the comments in\n\
  $(THIS_MAKEFILE)." | $${PAGER:-more}


# List of all targets except those that appear to be pattern-based
# or are full directory paths.  This gives us the targets you are
# most likely to be interested in.
#
list:
	$(AT) echo All dno targets:
	$(AT) $(REAL_MAKE) -pRrq -f $(THIS_MAKEFILE) : 2>/dev/null | \
	    awk '/^[^#]*:/ {if (($$0 !~ /\t/) && ($$0 !~ /=/)) \
		     {sub(/:.*/, ""); print}}' | uniq | \
	    grep -v '[%\\$$]' | grep '^[^/]' | sort -u | sed -e 's/^/  /'



# Local Variables:
# mode: makefile
# End:
