# 
#       Makefile for building and installing dno, the Arduino build
#       system
# 
#       Copyright (c) 2024 Marc Munro
#       Author:  Marc Munro
# 	License: GPL-3.0
#  
#

# TODO:
#  release stuff:
#    - ensure version is bumped
#    - ensure release date is bumped
#    - check dates (copyright) in headers

# Do not use make's built-in rules
# (this improves performance and avoids hard-to-debug behaviour).
#
MAKEFLAGS += -r


###########
# General definitions
#

# Figure out the path to this makefile, and to the makefile that we
# initially invoked.
#
MAKEFILEPATH := $(realpath $(call lastword,$(MAKEFILE_LIST)))
ROOT_MAKEFILE := $(firstword $(MAKEFILE_LIST))
ROOTDIR := $(realpath $(dir $(MAKEFILEPATH)))
BINDIR :=  $(realpath $(ROOTDIR)/../bin)


###########
# Helper definitions
#

# empty definition.  Needed by the succeeding definition for "space".
empty =

# An explicit space definition for use in macros.  Generally, macros
# eliminate leading spaces.  Using this definition will prevent that.
space = $(empty) $(empty)


###########
# Verbosity control.  Define VERBOSE on the command line to show the
# full compilation, etc commands.  If VERBOSE is defined $(FEEDBACK)
# will do nothing and $(AT) will have no effect, otherwise $(FEEDBACK)
# will perform an echo and $(AT) will make the command that follows it
# execute quietly.
# FEEDBACK_RAW may be used in multi-line shell commands where part of the
# command can usefully provide feedback.
#

# QUIET is used to prevent the automatic display of object size
# information.  VERBOSE can be used to force a more full display of
# object size info.

# Try to make the output of the avr-size executable a little more
# helpful.
#
ifndef VERBOSE
  ifdef QUIET
    # Make avr_size do nothing.  This breaks the verify_size target if
    # QUIET is defined but that seems acceptable.
    avr_size = true
  else
    # Define avr_size to handle parameters based on capability
    ifeq ($(SIZE_FOR_AVR),yes)
      ifeq ($(notdir $(avr_size)),$(notdir $(AVR_SIZE_CMD)))
        # There is a patched version of size that handles AVR with
        # prettier output.
        avr_flags = --format=avr
      endif
    endif
  endif
endif

ifdef VERBOSE
    FEEDBACK = @true
    FEEDBACK_RAW = true
    VERBOSEP = VERBOSE=y
    QUIET = 
    AT =
else
    FEEDBACK = @echo " "
    FEEDBACK_RAW = echo " "
    QUIET = 2>/dev/null
    AT = @
endif

include $(ROOTDIR)/Makefile.global

# Create a dependency between a file created by configure and its .in
# source file.  This will be called and eval'd to create the depencies
# dynamically.
#
define CONFIG_DEPENDENCY
$1: $1.in

endef

# Targets created by autoconf
# 
AUTOCONF_TARGETS = $(ROOTDIR)/configure 

# Targets created by configure.
#
DNO_SCRIPT_SRCS = $(wildcard bin/*.in)
DNO_DERIVED_SCRIPTS = $(DNO_SCRIPT_SRCS:%.in=%)
DNO_SRC_SCRIPTS = bin/dno_checksize
DNO_SCRIPTS = $(DNO_SRC_SCRIPTS) $(DNO_DERIVED_SCRIPTS)

DNO_MAN_SRCS = $(wildcard man/*.in)
DNO_DERIVED_MAN_SRCS = $(DNO_MAN_SRCS:%.in=%)

CONFIGURE_TARGETS = $(ROOTDIR)/Makefile.global \
		    $(DNO_DERIVED_SCRIPTS) $(DNO_DERIVED_MAN_SRCS)


################################################################
# Default target
#
.PHONY: DEFALT

# Make the executables that are generated from configure executable
# and unwritable.  This limits a developer's ability to edit the wrong
# file.
#
DEFAULT: $(CONFIGURE_TARGETS) bin docs
	@chmod 555 $(DNO_DERIVED_SCRIPTS)

# Dynamically create dependencies for each target derived from a .in
# file.
#
$(eval $(foreach script,$(DNO_DERIVED_SCRIPTS),\
         $(call CONFIG_DEPENDENCY,$(script))))

# Specific dependencies for each of the files generated by configure.
# This is used to force configure to be re-run if any of those input
# files are modified.
#
$(ROOTDIR)/Makefile.global: $(ROOTDIR)/Makefile.global.in 

# Run configure when any of the configure input files have been
# updated.
# Note that this makes the configure-generated files read-only to
# discourage accidentally editing them.  Note also the use of "grouped
# targets" ("&:").  This tells make that running this recipe updates
# *all* of the targets at once.
#
$(CONFIGURE_TARGETS) &: $(ROOTDIR)/configure
	$(FEEDBACK) CONFIGURE $(CONFIGURE_TARGETS)
	$(AT) (cd $(ROOTDIR); ./configure || exit 2) | sed -e 's/^/    /'
	$(AT) echo
	$(AT) chmod -w -f $(CONFIGURE_TARGETS)

# Automatically regenerate configure when configure.ac has been
# updated.  This rule allows for the non-existence of configure.ac and
# aclocal.m4, which could be the case with a distributed tarball
# (packaged release), allowing builds in the absence of autotools.
#
$(ROOTDIR)/configure: $(ROOTDIR)/configure.ac
	$(FEEDBACK) RECONFIGURING DNO
	$(AT)if [ -f $(ROOTDIR)/configure.ac ]; then \
	    if [ ! -d $(ROOTDIR)aclocal.m4 ]; then \
	        $(FEEDBACK_RAW) " " ACLOCAL; \
	        (cd $(ROOTDIR); aclocal); \
	    fi; \
	    $(FEEDBACK_RAW) " " AUTOCONF; \
	    (cd $(ROOTDIR); autoconf); \
	else \
	    echo "Canot find configure.ac" 1>&2; \
	    false; \
	fi

# Do nothing.  This allows make to work in the absence of configure.ac
# and autoconf, which will be the case for a packaged release.
#
$(ROOTDIR)/configure.ac $(ROOTDIR)/configure_board.ac :
	@>/dev/null


################################################################
# dno_requote
#
.PHONY: bin

bin: bin/dno_requote
bin/dno_requote: src/dno_requote.c
	$(FEEDBACK)  CC, LD [$(notdir $@)]
	$(AT) $(CC) $(LDFLAGS) -o $@ $<


################################################################
# Documentation targets
# 
.PHONY: docs

DNO_EXECUTABLES = dno dno_bpp dno_checksize dno_commands_for \
		  dno_dirinfo dno_menu dno_requote
DNO_MANPAGES_1 = $(patsubst %,man/%.1, $(DNO_EXECUTABLES))
DNO_MANPAGES_5 = man/BOARD_TYPE.5 man/BOARD_INFO.5 man/BOARD_OPTIONS.5
DNO_MANPAGES = $(DNO_MANPAGES_1) $(DNO_MANPAGES_5)


%.1: %.md
	$(FEEDBACK) PANDOC $@
	$(AT) pandoc  $< -s -t man | sed -e 's/<h1>/<h3>/' >$@

%.5: %.md
	$(FEEDBACK) PANDOC $@
	$(AT) pandoc  $< -s -t man | sed -e 's/<h1>/<h3>/' >$@

ifneq "$(shell which pandoc)" ""
docs: $(DNO_MANPAGES)
else
docs:
	@echo "UNABLE TO CREATE MAN PAGES; pandoc is not available." 1>&2
endif

# Create html from markdown.  This enables us to test formatting of
# markdown files.
#
%.html: %.md
	pandoc --shift-heading-level-by=-1 $*.md \
	       --standalone --to=html >$*.html

################################################################
# Install targets
# 
.PHONY: install uninstall

DNO_EXECUTABLE_FILES = $(patsubst %,bin/%, $(DNO_EXECUTABLES))
DNO_INSTALLABLES = $(patsubst %,$(INSTALL_BINDIR)/%, $(DNO_EXECUTABLES))

install: docs bin
	@echo Installing dno executables in $(INSTALL_BINDIR)
	@cp $(DNO_EXECUTABLE_FILES) $(INSTALL_BINDIR)
	@chmod 755 $(DNO_INSTALLABLES)
	@echo Install dno man pages in $(INSTALL_MANDIR)
	@cp $(DNO_MANPAGES_1) $(INSTALL_MANDIR)/man1
	@cp $(DNO_MANPAGES_5) $(INSTALL_MANDIR)/man5

uninstall:
	@echo Uninstalling dno man pages from $(INSTALL_MANDIR)
	@-cd $(INSTALL_MANDIR)/man1; rm -f $(notdir $(DNO_MANPAGES_1))
	@-cd $(INSTALL_MANDIR)/man5; rm -f $(notdir $(DNO_MANPAGES_5))
	@echo Uninstalling dno executables from $(INSTALL_BINDIR)
	@-rm $(DNO_INSTALLABLES)


################################################################
# Release targets
# 

.PHONY: release check_commit check_origin check_tag \
	check_remote 

release: check_commit check_origin check_remote \
	 check_tag

GIT_UPSTREAM = github origin

# Check that there are no uncomitted changes.
check_commit:
	@git status -s | wc -l | grep '^0$$' >/dev/null || \
	    (echo "    UNCOMMITTED CHANGES FOUND"; exit 2)

# Check that we have pushed the latest changes
check_origin:
	@err=0; \
	 for origin in $(GIT_UPSTREAM); do \
	    git diff --quiet master $${origin}/master 2>/dev/null || \
	    { echo "    UNPUSHED UPDATES FOR $${origin}"; \
	      err=2; }; \
	done; exit $$err

# Check that we have pushed the latest changes
check_remote:
	@err=0; \
	 for origin in $(GIT_UPSTREAM); do \
	    git remote show $${origin} 2>/dev/null | \
	    grep "^ *master.*up to date" >/dev/null || \
	    { echo "    UNPUSHED UPDATES FOR $${origin}"; \
	      err=2; }; \
	done; exit $$err

# Check that head has been tagged.  We assume that if it has, then it
# has been tagged correctly.
check_tag:
	@tag=`git tag --points-at HEAD`; \
	if [ "x$${tag}" = "x" ]; then \
	    echo "    NO GIT TAG IN PLACE"; \
	    exit 2; \
	fi


################################################################
# Cleanup targets
# 

garbage += \\\#*  .\\\#*  *~ 
GENERATED_FILES= *.1 *.5 Makefile.global dno_requote \
	$(DNO_DERIVED_SCRIPTS) $(DNO_DERIVED_MAN_SRCS)

clean:
	$(AT) rm -f $(garbage) $(GENERATED_FILES)
	$(AT) cd docs; rm -f $(garbage) $(GENERATED_FILES) 
	$(AT) cd man; rm -f $(garbage) $(GENERATED_FILES)
	$(AT) cd bin; rm -f $(garbage) $(GENERATED_FILES) 

distclean: clean
	$(AT) rm -rf configure config.log config.status \
		Makefile.global autom4te.cache

# Local Variables:
# mode: makefile
# End:
