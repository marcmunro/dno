<?xml version="1.0"?>
<chapter xmlns:d="http://docbook.org/ns/docbook" version="5.0"
	 xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>A Little Exploration</title>
  <para>
    The previous section shows how to get started with
    <literal>dno</literal> for a simple project.  It intoduces a lot of
    <literal>dno</literal>'s features and capabiliies without really
    explaining or delving into them.  So, let's look a little closer.
  </para>
  <section xml:id="dno_is_make">
    <title>On Being Based On <literal>make</literal></title>
    <section>
      <title>Dno Rebuilds Only What It Needs To</title>
      <para>
	We saw in the previous section that after everything had been
	compiled and linked, running <literal>dno</literal> again didn't
	do anything.
      </para>
      <para>
	This is because <literal>dno</literal> is based on
	<literal>make</literal> and understands the dependencies
	between <emphasis>everything</emphasis> that it builds.  If
	you update a source file, <literal>dno</literal> knows that
	the object for that source file has to be recreated because
	the object <emphasis>depends</emphasis> on that source file.
	Similarly, if that object file is part of a library, then the
	library <emphasis>depends</emphasis> on the object and must
	also be rebuilt.  And if the library or object is part of an
	image file, then the image <emphasis>depends</emphasis> on the
	library or object, and dno will re-link it.
      </para>
      <para>
	All of these dependencies are discovered automatically by
	<literal>dno</literal>.
      </para>
      <para>
	What all of this means, is that <literal>dno</literal> will
	only do as much work as it has to in order to achieve
	anything.  This makes compilations much faster and more
	efficient, making <literal>dno</literal> more pleasant to use
	than the standard, much slower, tools.
      </para>
      <para>
	XXX more on performance
      </para>
    </section>
    <section xml:id="targets">
      <title>Dno "Commands" Are <literal>make</literal> "Targets"</title>
      <para>
	We have been introduced to a number of different
	<literal>dno</literal> invocations:
	<itemizedlist>
	  <listitem>
	    <literal>dno BOARD_TYPE</literal>;
	  </listitem>
	  <listitem>
	    <literal>dno show_boards</literal>;
	  </listitem>
	  <listitem>
	    <literal>dno clean</literal>;
	  </listitem>
	  <listitem>
	    <literal>dno devices</literal>;
	  </listitem>
	  <listitem>
	    <literal>dno upload</literal>.
	  </listitem>
	</itemizedlist>
      </para>
      <para>
	Each of the "commands" after "<literal>dno</literal>" are, in
	make parlance, called targets.
      </para>
      <para>
	A target is something that make, and hence dno, knows how to
	build.  There is a recipe for building that target, and a set of
	dependencies.  Providing a target on the
	<literal>dno</literal> command line, tells it what you want it
	to do.
      </para>
      <para>
	Some targets are files, eg BOARD_TYPE, some are higher level,
	more abstract.  Some cause actions such as compilations,
	others simply provide information to the user.
      </para>
      <para>
	To get a list of the most useful targets, use <literal>dno
	help</literal>.
      </para>
      <para>
	If you run <literal>dno</literal> without an explicit target,
	it will attempt to build the default target.  What this will
	do, will depend on the type of directory you are in.   XXXX ref:
      </para>
    </section>
    <section>
      <title>Dno Accepts All Make Options</title>
      <para>
	Of particular interest here is the <literal>-j N</literal>
	option.  This allows make to perform multiple actions ("jobs")
	in parallel.  This can greatly reduce the compilation time for
	a large piece of software.  See man <literal>make</literal>
	manual page for more on this.
      </para>
    </section>
  </section>
  <section>
    <title>The Project Directory</title>
    <para>
      The name for a <literal>dno</literal> project comes from the
      name of the project directory.  The Arduino IDE handles this in
      much the same way, but setting the name in the Arduino IDE is
      more cumbersome.
    </para>
    <para>
      You can change the name of your project by simply changing the
      name of the project directory.  When you next run
      <literal>dno</literal>, it will figure out that the name has
      changed and will rebuild everything.
    </para>
  </section>
  <section xml:id="board_type">
    <title xml:id="board_type.title">
      The BOARD_TYPE File, And Board Types
    </title>
    <para>
      A <literal>BOARD_TYPE</literal> file identfies the type of board
      that <literal>dno</literal> is going to build code for.  Any
      time this changes <literal>dno</literal> will know it has to
      rebuild everything.
    </para>
    <para>
      As an alternative to an explicit <literal>BOARD_TYPE</literal>
      file, <literal>dno</literal> allows board-specific
      subdirectories to be added to a project.  These directories are
      given the name of the board in the same format as the contents
      of a <literal>BOARD_TYPE</literal> file.
    </para>
    <para>
      This allows you to build code for multiple types of boards
      within a single project.  Let's switch to this named-directory
      approach.  We'll start by looking at our current directory:
      <programlisting>
blink$ ls -l
- rw-r--r-- 1 marc marc  1233 Jan  6 11:04 blink.ino
-rw-r--r-- 1 marc marc 12860 Jan 10 16:33 BOARD_INFO
-rw-r--r-- 1 marc marc    18 Jan 10 16:33 BOARD_TYPE
drwxr-xr-x 3 marc marc  4096 Jan 10 16:33 build
blink$
      </programlisting>
    </para>
    <para>
      Here we see that we have our source code,
      <literal>blink.ino</literal>, our <literal>BOARD_TYPE</literal>
      and <literal>BOARD_INFO</literal> files, and a <literal>build
      directory</literal> where all of our objects, libraries and
      executables are stored.
    </para>
    <para>
      We'll want to clean this up before we create our new directory,
      as subsequent builds will be done there.  We could do this
      manually (with <literal>rm</literal> commands), or we can use a
      <literal>dno</literal> target to do this for us:
      <programlisting>
blink$ dno pristine
Super-cleaning .
blink$ ls -l
total 8
-rw-r--r-- 1 marc marc 1233 Jan  6 11:04 blink.ino
-rw-r--r-- 1 marc marc   18 Jan 10 16:42 BOARD_TYPE
blink$ rm BOARD_TYPE
blink$ ls -l
total 4
-rw-r--r-- 1 marc marc 1233 Jan  6 11:04 blink.ino
blink$
      </programlisting>
    </para>
    <para>
      The <literal>pristine</literal> target is a slighty souped-up
      version of the <literal>clean</literal> target.  Clean will
      remove the <literal>build</literal> directory and its contents.
      Pristine additionally removes the <literal>BOARD_INFO</literal>
      directory.  Note that we still had to manually remove 
      <literal>BOARD_TYPE</literal>.
    </para>
    <para>
      Now, we create the new directory, move into it and run
      <literal>dno</literal> again:
      <programlisting>
blink$ mkdir pro.8MHzatmega328
blink$ cd pro.8MHzatmega328
pro.8MHzatmega328$ dno
  Creating BOARD_INFO...
  C++  [..] blink.ino
  AS  [core] wiring_pulse.S
  C  [core] wiring_shift.c
  C  [core] wiring_pulse.c
  C  [core] wiring_digital.c
  C  [core] wiring.c
  C  [core] wiring_analog.c
  C  [core] WInterrupts.c
  C  [core] hooks.c
  C++  [core] WString.cpp
  C++  [core] WMath.cpp
  C++  [core] USBCore.cpp
  C++  [core] Tone.cpp
  C++  [core] Stream.cpp
  C++  [core] Print.cpp
  C++  [core] PluggableUSB.cpp
  C++  [core] new.cpp
  C++  [core] main.cpp
  C++  [core] IPAddress.cpp
  C++  [core] HardwareSerial.cpp
  C++  [core] HardwareSerial3.cpp
  C++  [core] HardwareSerial2.cpp
  C++  [core] HardwareSerial1.cpp
  C++  [core] HardwareSerial0.cpp
  C++  [core] CDC.cpp
  C++  [core] abi.cpp
  AR [libcore] abi.o...
  LD blink.ino.o
  OBJCOPY (hex) blink.elf
pro.8MHzatmega328$ 
      </programlisting>
    </para>
    <para>
      Having explicit board directories like this keeps the parent
      code directory cleaner and eliminates the unsightly
      <literal>BOARD_TYPE</literal> file.  This is the recommended way
      to use <literal>dno</literal>.
    </para>
  </section>
  <section>
    <title>Cleaning</title>
    <para>
      The section above introduced the "clean" and "pristine"
      targets.  These, along with "tidy" are used for carefully
      cleaning up unwanted files.
    </para>
    <para>
      Although it is easy enough to use the <literal>rm</literal>
      command to remove unwanted files, it is very easy to mistype and
      delete files that you actually want to keep.  Using the
      <literal>clean</literal> and related targets allows you to
      remove junk files safely.
    </para>
    <para>
      Note that all of the cleaning targets work in the current
      directory as well as its descendents.
    </para>
    <section>
      <title><literal>Tidy</literal></title>
      <para>
	The <literal>tidy</literal> target removes all files that look
	like garbage.  This includes emacs' backup and auto-save files.
      </para>
    </section>
    <section>
      <title><literal>Clean</literal></title>
      <para>
	The <literal>Clean</literal> target does all that the
	<literal>tidy</literal> target does as well as removing
	<literal>build</literal> and <literal>html</literal>
	directories, which will be recreated when
	<literal>dno</literal> is next run.
      </para>
    </section>
    <section>
      <title><literal>Pristine</literal></title>
      <para>
	The <literal>pristine</literal> target does all that the
	<literal>clean</literal> target does, plus it removes any
	<literal>BOARD_INFO</literal> files.
      </para>
      <para>
	Use this before committing changes into your repository, or
	before building source distribution tarballs.
      </para>
    </section>
  </section>
  <section>
    <title>The BOARD_INFO file</title>
    <para>
      The <literal>BOARD_INFO</literal> file is derived from the
      files:
      	<itemizedlist>
	  <listitem>
	    <literal>platform.txt</literal>;
	  </listitem>
	  <listitem>
	    <literal>boards.txt</literal>;
	  </listitem>
	  <listitem>
	    <literal>platform.local.txt</literal>.
	  </listitem>
	</itemizedlist>
    </para>
    <para>
      For more about these files please see the
      <link xlink:href="https://arduino.github.io/arduino-cli/0.21/platform-specification/">
	Arduino Platform Specification</link>.
    </para>
    <para>
      Dno parses these files, based on the user's
      <link linkend='board_type' endterm="board_type.title">
	board selection
      </link>, creating a file that conforms with
      <literal>makefile</literal> syntax and provides all of the
      definitions necessary for compiling, linking, etc, Arduino
      programs.
    </para>
  </section>
  <section>
    <title>The BOARD_OPTIONS file</title>
    <para>
      The <literal>BOARD_OPTIONS</literal> file describes selected,
      non-default, board-specific configuration values.
    </para>
    <para>
      It is created by running <literal>dno menu</literal>, which
      presents the user with menus of board-specific configuration
      options.  If the user selects any non-default options, a
      <literal>BOARD_OPTIONS</literal> file will be created to
      document the selections.
    </para>
  </section>
  <section>
    <title>Devices</title>
    <para>
      XXXX
      dno devices
    </para>
    <para>
      XXXX
      Use of screen
    </para>
    <para>
      XXXX
      Upload and eeprom
    </para>
    <para>
    </para>
  </section>
  <section>
    <title>Performance</title>
    <para>
      XXXX
      Comparisons with the CLI as used by the Arduino IDE
    </para>
    <para>
      How to make it even faster
    </para>
    <para>
    </para>
    <para>
    </para>
  </section>
</chapter>
